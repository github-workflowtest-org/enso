from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Errors.Illegal_State.Illegal_State
import Standard.Base.Runtime.Ref.Ref

from Standard.Table import Table, Value_Type, Aggregate_Column, Bits, expr
from Standard.Table.Errors import Invalid_Column_Names, Inexact_Type_Coercion, Duplicate_Output_Column_Names

import Standard.Database.DB_Column.DB_Column
import Standard.Database.DB_Table.DB_Table
import Standard.Database.SQL_Type.SQL_Type
import Standard.Database.Internal.Replace_Params.Replace_Params
from Standard.Database import all
from Standard.Database.Errors import all

from Standard.Microsoft import all

from Standard.Test import all
import Standard.Test.Test_Environment

import enso_dev.Table_Tests
import enso_dev.Table_Tests.Database.Common.Common_Spec
import enso_dev.Table_Tests.Database.Transaction_Spec
import enso_dev.Table_Tests.Database.Upload_Spec
import enso_dev.Table_Tests.Database.Helpers.Name_Generator
import enso_dev.Table_Tests.Common_Table_Operations
from enso_dev.Table_Tests.Common_Table_Operations.Util import all
from enso_dev.Table_Tests.Database.Types.Postgres_Type_Mapping_Spec import default_text
from enso_dev.Table_Tests.Database.Postgres_Spec import Basic_Test_Data, Postgres_Tables_Data

import enso_dev.Base_Tests.Network.Enso_Cloud.Cloud_Tests_Setup.Cloud_Tests_Setup

type SQLServer_Info_Data
    Value ~data

    connection self = self.data.at 0
    tinfo self = self.data.at 1
    t self = self.data.at 2

    setup default_connection = SQLServer_Info_Data.Value <|
        connection = default_connection
        tinfo = Name_Generator.random_name "Tinfo"
        connection.execute_update 'Create Table "'+tinfo+'" ("strs" VARCHAR(255), "ints" BIGINT, "bools" BIT, "doubles" FLOAT)'
        t = connection.query (SQL_Query.Table_Name tinfo)
        row1 = ["a", Nothing, False, 1.2]
        row2 = ["abc", Nothing, Nothing, 1.3]
        row3 = ["def", 42, True, 1.4]
        Panic.rethrow <|
            t.update_rows (Table.from_rows ["strs", "ints", "bools", "doubles"] [row1, row2, row3]) update_action=Update_Action.Insert

        [connection, tinfo, t]

    teardown self =
        self.connection.execute_update 'DROP TABLE "'+self.tinfo+'"'
        self.connection.close

get_configured_connection_details =
    host = Environment.get "ENSO_SQLSERVER_HOST" if_missing="localhost"
    port = Environment.get "ENSO_SQLSERVER_PORT" if_missing="1433"
    user = Environment.get "ENSO_SQLSERVER_USER" if_missing="sa"
    password = Environment.get "ENSO_SQLSERVER_PASSWORD" if_missing="<YourStrong@Passw0rd>"
    database = Environment.get "ENSO_SQLSERVER_DATABASE" if_missing="test"
    resolved_password = if password.starts_with "enso://" then Enso_Secret.get password else password
    credentials = Credentials.Username_And_Password user resolved_password
    SQLServer_Details.SQLServer host port credentials database

## Returns a function that takes anything and returns a new connection.
   The function creates a _new_ connection on each invocation
   (this is needed for some tests that need multiple distinct connections).
create_connection_builder =
    connection_details = get_configured_connection_details
    connection_details.if_not_nothing <|
        _ -> Database.connect connection_details

add_specs suite_builder =
    suite_builder.group "[SQLServer] Info" group_builder->
        default_connection = Database.connect get_configured_connection_details
        data = SQLServer_Info_Data.setup default_connection

        group_builder.teardown <|
            data.teardown

        group_builder.specify "should return Table information" <|
            i = data.t.column_info
            i.at "Column" . to_vector . should_equal ["strs", "ints", "bools", "doubles"]
            i.at "Items Count" . to_vector . should_equal [3, 1, 2, 3]
            i.at "Value Type" . to_vector . should_equal [Value_Type.Char 255, Value_Type.Integer, Value_Type.Boolean, Value_Type.Float]

        group_builder.specify "should return Table information, also for aggregated results" <|
            i = data.t.aggregate columns=[Aggregate_Column.Sum "ints", Aggregate_Column.Count_Distinct "bools"] . column_info
            i.at "Column" . to_vector . should_equal ["Sum ints", "Count Distinct bools"]
            i.at "Items Count" . to_vector . should_equal [1, 1]
            i.at "Value Type" . to_vector . should_equal [Value_Type.Integer, Value_Type.Integer ..Bits_32]

        group_builder.specify "should infer standard types correctly" <|
            data.t.at "strs" . value_type . is_text . should_be_true
            data.t.at "ints" . value_type . is_integer . should_be_true
            data.t.at "bools" . value_type . is_boolean . should_be_true
            data.t.at "doubles" . value_type . is_floating_point . should_be_true

        group_builder.specify "should preserve SQLServer types when table is materialized, where possible" pending="TODO" <|
            name = Name_Generator.random_name "types-test"
            Problems.assume_no_problems <|
                data.connection.execute_update 'CREATE TABLE "'+name+'" ("int4" int4, "int2" int2, "txt-limited" varchar(10), "txt-fixed" char(3))'
            t1 = data.connection.query (SQL_Query.Table_Name name)
            t1.at "int4" . value_type . should_equal (Value_Type.Integer Bits.Bits_32)
            t1.at "int2" . value_type . should_equal (Value_Type.Integer Bits.Bits_16)
            t1.at "txt-limited" . value_type . should_equal (Value_Type.Char size=10 variable_length=True)
            t1.at "txt-fixed" . value_type . should_equal (Value_Type.Char size=3 variable_length=False)

            in_memory = t1.read
            in_memory.at "int4" . value_type . should_equal (Value_Type.Integer Bits.Bits_32)
            in_memory.at "int2" . value_type . should_equal (Value_Type.Integer Bits.Bits_16)
            in_memory.at "txt-limited" . value_type . should_equal (Value_Type.Char size=10 variable_length=True)
            in_memory.at "txt-fixed" . value_type . should_equal (Value_Type.Char size=3 variable_length=False)


        group_builder.specify "basic query" <|
            conn = Database.connect get_configured_connection_details
            conn.should_succeed
            new_database = conn.read (SQL_Query.Raw_SQL "SELECT 'master' as c") . at 0 . to_vector . first
            new_database.should_equal "master"

main filter=Nothing =
    suite = Test.build suite_builder->
        add_specs suite_builder
    suite.run_with_filter filter
