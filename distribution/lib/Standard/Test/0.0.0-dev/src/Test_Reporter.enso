private

from Standard.Base import all
import Standard.Base.Runtime.Context
import Standard.Base.Runtime.Ref.Ref
from Standard.Base.Runtime import assert

import project.Group.Group
import project.Internal.Stack_Trace_Helpers
import project.Spec_Result.Spec_Result
import project.Suite_Config.Suite_Config
import project.Test.Test
import project.Test_Result.Test_Result

polyglot java import java.lang.StringBuilder
polyglot java import java.lang.System as Java_System

## PRIVATE
   Write the JUnit XML header.
wrap_junit_testsuites : Suite_Config -> (StringBuilder|Nothing) -> Any -> Nothing
wrap_junit_testsuites config builder ~action =
    if config.should_output_junit then
        builder.append '<?xml version="1.0" encoding="UTF-8"?>\n'
        builder.append '<testsuites>\n'

    result = action

    if config.should_output_junit then
        builder.append '</testsuites>\n'

        Context.Output.with_enabled <|
            config.output_path.parent.create_directory
            builder.toString.write config.output_path

    result


red text =
    '\u001b[31;1m' + text + '\u001b[0m'

green text =
    '\u001b[32;1m' + text + '\u001b[0m'

highlighted text =
    '\u001b[1;1m' + text + '\u001b[0m'

grey text =
    '\u001b[90m' + text + '\u001b[0m'

maybe_red_text (text : Text) (config : Suite_Config) =
    if config.use_ansi_colors then (red text) else text

maybe_green_text (text : Text) (config : Suite_Config) =
    if config.use_ansi_colors then (green text) else text

maybe_highlighted_text (text : Text) (config : Suite_Config) =
    if config.use_ansi_colors then (highlighted text) else text

maybe_grey_text (text : Text) (config : Suite_Config) =
    if config.use_ansi_colors then (grey text) else text

## Print result for a single Spec run
print_single_result : Test_Result -> Suite_Config -> Nothing
print_single_result (test_result : Test_Result) (config : Suite_Config) =
    times_suffix =
        times = test_result.time_taken.total_milliseconds.to_text + "ms"
        "[" + times + "]"

    decorate_stack_trace = case config.use_ansi_colors && config.caller_project_root.is_nothing.not of
        True -> Stack_Trace_Helpers.decorate_stack_trace_text config.caller_project_root (maybe_highlighted_text _ config)
        False -> (x->x)

    case test_result.spec_result of
        Spec_Result.Success ->
            if config.print_only_failures.not then
                txt = "    - " + test_result.spec_name + " " + times_suffix
                IO.println (maybe_green_text txt config)
        Spec_Result.Failure msg details ->
            txt = "    - [FAILED] " + test_result.spec_name + " " + times_suffix
            IO.println (maybe_red_text txt config)
            IO.println ("        Reason: " + msg)
            if details.is_nothing.not then
                IO.println (decorate_stack_trace details)
        Spec_Result.Pending reason ->
            if config.print_only_failures.not then
                IO.println (maybe_grey_text ("    - [PENDING] " + test_result.spec_name) config)
                IO.println ("        Reason: " + reason)


## Prints all the results, optionally writing them to a jUnit XML output.

   Arguments:
   - test_results: Vector of `Test_Result`. Can be empty. Can contain results from multiple
                   groups.
   - builder: StringBuilder or Nothing. If StringBuilder, then a jUnit XML format is appended to
              that StringBuilder.
print_report : Vector Test_Result -> Suite_Config -> (StringBuilder | Nothing) -> Nothing
print_report (test_results : Vector Test_Result) (config : Suite_Config) (builder : (StringBuilder | Nothing)) =
    distinct_group_names = test_results.map (_.group_name) . distinct
    results_per_group = distinct_group_names.fold Map.empty acc-> group_name->
        group_results = test_results.filter res->
            res.group_name == group_name
        assert (group_results.length > 0)
        acc.insert group_name group_results
    results_per_group.each_with_key group_name-> group_results->
        print_group_report group_name group_results config builder

## Prints a pending group, optionally writing it to a jUnit XML output.
print_pending_group : Group -> Suite_Config -> (StringBuilder | Nothing) -> Nothing
print_pending_group group config builder =
    assert group.pending.is_nothing.not "Group in print_pending_group should be pending"
    if config.should_output_junit then
        assert builder.is_nothing.not "Builder must be specified when JUnit output is enabled"
        builder.append ('    <testsuite name="' + (escape_xml group.name inside_attribute=True) + '" timestamp="' + (Date_Time.now.format "yyyy-MM-dd'T'HH:mm:ss") + '"')
        builder.append (' tests="0" disabled="1" errors="0" time="0.0">\n')
        builder.append ('        <testcase name="PENDING" time="0.0">\n')
        builder.append ('            <skipped message="Reason: '+(escape_xml group.pending inside_attribute=True)+'"/>\n')
        builder.append ('        </testcase>\n')
        builder.append '    </testsuite>\n'
    IO.println <| maybe_grey_text ("[PENDING] " + group.name) config
    IO.println ("    Reason: " + group.pending)

## Prints report for test_results from a single group.

   Arguments:
   - test_results: Test test_results from a single group
print_group_report : Text -> Vector Test_Result -> Suite_Config -> (StringBuilder|Nothing) -> Nothing
print_group_report group_name test_results config builder =
    distinct_groups = test_results.distinct (res-> res.group_name)
    assert (distinct_groups.length == 1)
    total_time = test_results.fold Duration.zero acc-> res->
        acc + res.time_taken
    if config.should_output_junit then
        assert builder.is_nothing.not "Builder must be specified when JUnit output is enabled"
        builder.append ('    <testsuite name="' + (escape_xml group_name inside_attribute=True) + '" timestamp="' + (Date_Time.now.format "yyyy-MM-dd'T'HH:mm:ss") + '"')
        builder.append (' tests="' + test_results.length.to_text + '"')
        builder.append (' disabled="' + test_results.filter _.is_pending . length . to_text + '"')
        builder.append (' errors="' + test_results.filter _.is_fail . length . to_text + '"')
        builder.append (' time="' + total_time.total_seconds.to_text + '"')
        builder.append ('>\n')

        test_results.each result->
            builder.append ('        <testcase name="' + (escape_xml result.spec_name inside_attribute=True) + '" time="' + ((result.time_taken.total_milliseconds / 1000.0).to_text) + '">')
            case result.spec_result of
                Spec_Result.Success -> Nothing
                Spec_Result.Failure msg details ->
                    builder.append ('\n            <failure message="' + (escape_xml msg inside_attribute=True) + '">\n')
                    # We always print the message again as content - otherwise the GitHub action may fail to parse it.
                    builder.append (escape_xml msg)
                    if details.is_nothing.not then
                        ## If there are additional details, we print them as well.
                        builder.append '\n\n'
                        builder.append (escape_xml details)
                    builder.append '\n            </failure>\n'
                Spec_Result.Pending msg -> builder.append ('\n            <skipped message="' + (escape_xml msg inside_attribute=True) + '"/>\n        ')
            builder.append '        </testcase>\n'
        builder.append '    </testsuite>\n'

    should_print_behavior = config.print_only_failures.not || test_results.any (r -> r.is_fail)
    if should_print_behavior then
        tests_succeeded = test_results.fold 0 acc-> res->
            if res.is_success then acc + 1 else acc
        tests_failed = test_results.fold 0 acc-> res->
            if res.is_fail then acc + 1 else acc
        some_test_failed = tests_failed > 0
        tests_executed = tests_succeeded + tests_failed
        group_description =
            counts = tests_succeeded.to_text + "/" + tests_executed.to_text
            times = total_time.total_milliseconds.to_text + "ms"
            group_name + ": " + "[" + counts + ", " + times + "]"
        IO.println <| case some_test_failed of
            True -> maybe_red_text ("[FAILED] " + group_description) config
            False -> maybe_green_text group_description config
        test_results.each result->
            print_single_result result config

## PRIVATE
   Escape Text for XML
escape_xml : Text -> Boolean -> Text
escape_xml input inside_attribute=False =
    escaped = input.replace '&' '&amp;' . replace '"' '&quot;' . replace "'" '&apos;' . replace '<' '&lt;' . replace '>' '&gt;'
    if inside_attribute then escaped.replace '\n' '&#10;' else escaped

## PRIVATE
progress_width = 70

## PRIVATE
print_progress current_progress total_count status_text =
    total_count_as_text = total_count.to_text
    counter_width = total_count_as_text.length
    current_progress_as_text = current_progress.to_text.pad counter_width at=Location.Start
    line = " ("+ current_progress_as_text + " / " + total_count_as_text + ") " + status_text
    truncated_line = if line.length <= progress_width then line else
        line.take (progress_width - 3) + '...'

    Java_System.out.print '\r'
    Java_System.out.print (' ' * progress_width)
    Java_System.out.print '\r'
    Java_System.out.print truncated_line
    Java_System.out.print '\r'

## PRIVATE
clear_progress =
    Java_System.out.print '\r'
    Java_System.out.print (' ' * progress_width)
    Java_System.out.print '\r'

## PRIVATE
type Ignore_Progress_Reporter
    ## PRIVATE
    report_progress self (status_text : Text) (increment : Integer = 1) =
        _ = [increment, status_text]
        Nothing

    ## PRIVATE
    clear = Nothing

## PRIVATE
type Command_Line_Progress_Reporter
    ## PRIVATE
    Value current_progress total_count

    ## PRIVATE
    make total_expected =
        Command_Line_Progress_Reporter.Value (Ref.new 0) total_expected

    ## PRIVATE
    report_progress self (status_text : Text) (increment : Integer = 1) =
        self.current_progress.modify (+increment)
        print_progress self.current_progress.get self.total_count status_text

    ## PRIVATE
    clear self = clear_progress

## PRIVATE
   Checks if the current process is running in an interactive terminal session.
is_terminal_interactive -> Boolean =
    Java_System.console != Nothing
